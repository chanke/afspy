Structure of afspy

Configuration
=============

Config options are read as :
1. read system wide configuration file:
   Path is hard-coded in module
2. read user's personal $HOME/.config/afspy
3. read config file given on command line
4. use options given on command line

Later definitions overwrite earlier.
This configuration is stored in a AfsConfig-object.

An application has to initialize it and pass it on to
any service used.
Of course the application can modify AfsConfig beforehand.

# FixMe: we could store the default AfsConfig-Object in the module afs
# and use that if no config-object is given

Contents of the AfsConfig :
=====================

- Credential to use :
    """
    - use present
    - use keytab from file ...
    - pagsh; kinit  -k -t  $KRB5CCNAME; aklog ; call child..
    """
- Cellname
- DAO-implementation to use
- DB-implementation to use.

Policies :
========

* DAO returns dictionary of list of dicts
* DAO always raises an execption on error
* DAO are agnostic of the model.
* Partitions are used canonicalized only
* Id are integer. DAO has to convert it.  Same for quota,  number of files access
* Timestamps are datetime.
* DAOs are distinguished on the RPC-Level.
* Services never call another service,  but multiple DAOs


DB-Cacheing
===========

If the option DB_CACHE is set to True.
A connection to the configured DB is set up 
and stored in the AfsConfig-Object.
Since every Service gets an AfsConfig-Object with a valid DB connection,
it just has to create a session and go on with its business.

Any Instance of a Model-Object has to be detached from the sqlalchemy-session, so it 
can be used as a normal object.

LiveCommand Execution
====================
Live commands are executed in a separate process.


Names:
=======
BNode instead of Process.

